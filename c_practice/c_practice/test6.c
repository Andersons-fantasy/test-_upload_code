#include <stdio.h>
//main(){
	//------右移操作符
	/*int a = -5;
	int b = a >> 1;*/
	
//-------按位与
	/*int a = 2;
	int b = 4;
	int c = a&b;
	printf("%d\n",c);*/
	//________不用创建第三个变量，将a和b的值交换 (不建议使用，1.执行效率没有第三变量的高 2.可读性较差)
	// 异或 1^0=1 这三个数字随便两个数字进行异或操作都会得到第三个数字
	/*int a = 10;
	int b = 45;
	printf("a = %d, b = %d\n",a,b);
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a = %d, b = %d\n",a,b);*/
	//---------得到一个整数的二进制位上有多少个1
	//ret = num&1就可以得到num二进制位最后一位是0还是1，再将num>>1右移移位，直到32个二进制位查完
	/*int num,i,count = 0;
	scanf("%d",&num);*/
	// -----该方法必须循环32次，思考还有没有更优化的方法
	//for(i=0;i<32;i++){
	//	//此方法改变了num的值
	//	/*if(num & 1 == 1){
	//		count ++;
	//	}
	//	num = num >> 1;*/
	//	//不改变num的值
	//	if((num >> i) & 1 == 1){
	//		count++;
	//	}
	//}
	// -----------优化
	//while(num){         //只要num不为0就有1
	//	count++;
	//	num = num & (num - 1);  //比如1111000 &（1111000 - 1）即1111000 & 1111011 = 1111000  消除了一个1 
	//}
	
	//------------------数组也是有类型的  必须int arr[10]的类型就是int [10]
	//printf("%d\n",sizeof(int [3][3]));
	//------------------字符在内存中占1个字节，字符串占（字符数+1'\0'）个字节
	//printf("%d\n",sizeof(char));

	/*printf("%d",count);*/
	//----------------sizeof()
	//short a = 0;
	//int s = 0;
	//printf("%d\n",sizeof(a = s + 2));    //a 的类型是short 内存占两个字节，sizeof（）括号里面的运算只是一个摆设，不会算入程序逻辑里
	//printf("%d\n", s);           //sizeof()括号里面的运算只是一个摆设
	//--------------- ^取反操作符的用法
	//int a = 10;                //00000000000000000000000000001010  将第三个0改为1
	//a |= (1 << 2);             //00000000000000000000000000000100  将1左移2位，再将它和a进行按位或操作
	//printf("%d\n",a);          //00000000000000000000000000001110  结果是15
	//                           //再将第三个1改回0
	//						   //11111111111111111111111111111011  将该数字按位与&上a就可以实现
	//                           //00000000000000000000000000000100  将1左移两位再取反就可以得到上面的数字
	//a &= ~(1 << 2);
	//printf("%d\n",a);
	//int a = 1;
	//int b = 2;
	//int c = 3;
	//int d = 4;
	//int e = a++ && ++b && d++;     //&&的算法是只要出现一个0就=0，不再进行后续判断和操作  ||同理，只要出现一个1就返回1，不会进行后续操作
	//printf("%d %d %d %d",a,b,c,d);
	// ------------------逗号表达式
	/*int a = 0;
	int b = 1;
	if(a = 1, b = a + 1 , a > b){
		printf("呵呵");
	}else{
		printf("哈哈");
	}*/
//}
	//------------------     结构体指针操作符 ->
	//struct stu{
	//	char name[20];
	//	int age;
	//	char clas[];
	//};
	//main(){
	//	struct stu s1 = {"张三", 18, "汽服1904"};
	//	struct stu* ps = &s1;
	//	printf("%s\n",s1.name);
	//	printf("%s\n", (*ps).name);
	//	//结构体指针操作符   结构体指针->成员名
	//	printf("%s\n",ps ->name);
	//}
//1111 1111
//1111 1110
//1000 0001
//main(){
//	char a = 5;    //整数（4字节）放进char类型（1个字节）进行取断，只留后8个二进制位
//	// 00000101
//	char b = 122;
//	// 01111010
//	char c = a + b;        //进行加减乘除时将char类型进行符号位整型提升，也就是最左边是0就在前面补24个0，如果是1就补24个1；运算结束再对结果进行截断赋值给c 
//	// 00000000000000000000000000000101
//	// 00000000000000000000000001111010
//	//c00000000000000000000000001111111  
//	//c                        01111111  取断 
//	printf("%c\n",a);
//	printf("%d\n",a);
//	//c                        01111111
//	//c00000000000000000000000001111111 符号位整型提升 此时是补码(正整数补码，反码，原码都一样)
//	// 00000000000000000000000001111111 反码
//	// 00000000000000000000000001111111 原码
//	printf("%d\n",c);
//	printf("%d\n",sizeof(c));   // 1
//
//	printf("%d\n",sizeof(+c));    // 4 只要运算，就会有整型提升
//}
//-----------------a * b + c * d + e * f 该表达式不能确定第三个*比第一个+谁先执行
//-----------------只能确定两个相邻操作符的优先级 ret1 + ret2 + e * f 从左到右判断 + + 但又因为* 比+ 的优先级高 ，所以不确定 第一个+ 和*谁先执行
//-----------------尽量避免写这种表达式
//main(){
//	int a = 1, b = 2, c = 3, d = 4, e = 5, f = 6;
//	int sum = a * b + c * d + e * f;
//	printf("%d\n",sum);
//}   //-----------------可以得到结果
//main(){
//	int c = 2;
//	int b = c + --c;
//	printf("%d\n",b);
//}   //结果为2,编译器不同结果可能不同

//----------------------野指针
//指针未初始化
//int* p; 应该给p一个初始化值
//指针越界
//int arr[10];使用时就只有int* p = &arr[10]没有int* p = &arr[11];
//指针是局部变量
//int* test(){
//	int a = 10;
//	return &a;
//}
//main(){
//	int* p = test();
//	printf("%d\n",*p);
//	printf("%p\n",p);
//}
//----------------------指针减去指针等于中间的元素个数(两个指针指向同一空间)
//main(){
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
//	printf("%d\n",&arr[10]-&arr[9]);
//	printf("%d\n",&arr[9]-&arr[0]);
//}
//-----------------指针实现strlen的用法
//#include <string.h>
//int my_strlen(char* arr){
//	int count = 0;
//	while(*arr != '\0'){
//		count++;
//		arr++;
//	}
//	return count;
//	/*char* start = arr;
//	char* end = arr;
//	while(*end != '\0'){
//		end++;
//	}
//	return end-start;*/
//}
//main(){
//	char arr[] = "hello world!";
//	int a = strlen(arr);
//	int b = my_strlen(arr);
//	printf("%d\n",a);
//	printf("%d\n",b);
//}
//-----------------------标准规定----数组里面指针的比较只能允许和数组最后一个元素后面的指针进行比较，不允许和第一个前面的指针进行比较
//#include <string.h>
//main(){
//	char arr[] = "hello world!";
//	char* vp;
//	int i;
//	//for(vp = &arr[strlen(arr)];vp > &arr[0];){          //不会和第一个前面的指针比较
//	//	* --vp = '0';
//	//}
//	for(vp = &arr[strlen(arr) - 1];vp >= &arr[0]; vp --){           //会和第一个前面的指针比较
//		*vp = '0';
//	}
//	for(i = 0; i < strlen(arr); i++){
//		printf("%c\n",arr[i]);
//	}
//}
// ----------------------------有char arr[10];打印arr是数组首元素的地址；打印&arr是整个数组的地址.
// ----------------------------因为arr+1是后面一个元素的地址，&arr+1是数组后面的指针，加了一个数组的大小

//-----------------------------冒泡排序
//#include <stdio.h>
//main(){
//	int arr[10] = {112,12,32,45,765,2,5,4,65,453};
//	int i,j;
//	int len = sizeof(arr)/sizeof(arr[0]);
//	printf("%d\n",len);
//	for(j = 0; j < len - 1; j++){
//		for(i = 0; i < len - j - 1; i++){
//			if(arr[i] > arr[i+1]){
//				int a = arr[i];
//				arr[i] = arr[i+1];
//				arr[i+1] = a;
//			}
//		}
//	}
//	for(i=0;i<10;i++){
//		printf("%d ",arr[i]);
//	}
//}
// ----------------------创建整型数组，实现init(),print(),reverse()
//#include <stdio.h>
//void print(int* arr, int len){
//	int i;
//	for(i = 0; i < len; i++){
//		printf("%d ",*arr);
//		arr++;
//	}
//	printf("\n");
//}
//void init(int* arr, int len){
//	int i;
//	for(i = 0; i < len; i++){
//		arr[i] = 0;
//	}
//}
//void reverse(int* arr, int len){
//	//int i;
//	//for(i = 0; i < len/2; i++){
//	//	int a = arr[i];
//	//	arr[i] = arr[len - 1 - i];
//	//	arr[len - 1 - i] = a;
//	//}
//	int left = 0;
//	int right = len - 1;
//	while(left < right){
//		int tmp;                              //temporary,暂时的
//		tmp = arr[left];
//		arr[left] = arr[right];
//		arr[right] = tmp;
//		left ++;
//		right --;
//	}
//}
//main(){
//	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
//	int len = sizeof(arr)/sizeof(arr[0]);
//	print(arr,len);
//	reverse(arr,len);
//	print(arr,len);
//	init(arr,len);
//	print(arr,len);
//}

// -----------------------------交换两个数组
//main(){
//	int arr1[10] = {1,2,3,23,5,6,7,8,9,10};
//	int arr2[10] = {10,9,8,7,6,5,4,3,2,1};
//	int len = sizeof(arr1)/sizeof(arr1[0]);
//	int i;
//	for(i=0;i<len;i++){
//		int tmp = arr1[i];
//		arr1[i] = arr2[i];
//		arr2[i] = tmp;
//	}
//	print(arr1,len);
//	print(arr2,len);
//}
// -----------------------------int i;如果是全局变量，默认为
// -----------------------------sizeof()返回的是无符号数，当无符号数与整数比较时，整数无论正负都会转化为无符号数。
// ------------------------------ 也就是-1和sizeof（）比较时，-1的符号位加入计算不再是符号位
// -1
// 100000000000000000000000000000000000001
// 111111111111111111111111111111111111110
// 111111111111111111111111111111111111111
// 111111111111111111111111111111111111111(unsigned) 无符号数 原码 反码 补码 相同
// c += a++ + b   //先将a+c+b赋值给b，再a++

//---------------------------------求两个数二进制表达式中位上的数不同的位数
//main(){
//	int a,b,i;
//	
//	int c;
//	int count = 0;
//	scanf("%d%d",&a,&b);
//	c = a^b;               //1101^0111 = 1010  里面有几个1就有几个不同的位数
//	for(i=0;i<32;i++){
//		if(c>>i & 1 == 1)               //操作符能精简的就精简一下
//			count++;
//	}
	///*while(c){
	//	c = c & (c - 1);                    // 1101 & 1100 = 1100 消去一个1
	//	count ++;
	//}*/                             // -----------这种方法更高效， 不用循环32次，有多少位数就循环多少次
//	printf("%d\n",count);
//	/*int c = 2;
//	c >> 1;                       
//	printf("%d\n",c);*/                    //------移位操作符不改变操作对象的值
//}

// ---------------------------------//输出无符号的整数    %u
// --------------------  -1转换为unsigned int是补码转换为原码并且111111111111111111111111111111111的首位符号位为有效位
//main(){
//	unsigned int a;
//	scanf("%d",&a);
//	printf("%u\n",a);
//}
// -------------------------------打印二进制的奇数位和偶数位
//main(){
//	int a = -1;
//	int i;
//	for(i=16; i>0;i--){
//		if((a>>(2*i-1))&1==1){
//			printf("1");            //可以直接printf("%d",(2*i-1))&1);
//		}else{
//			printf("0");
//		}
//	}
//	printf("\n");
//	for(i=16; i>0;i--){
//		if((a>>(2*i-2))&1==1){
//			printf("1");
//		}else{
//			printf("0");
//		}
//	}
//}